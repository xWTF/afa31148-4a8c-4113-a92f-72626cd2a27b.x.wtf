<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>给 Windows Server 2022 配置 Windows Hello 指纹解锁</title>
      <link href="/2021/fingerprint-unlocking-for-windows-server-2022/"/>
      <url>/2021/fingerprint-unlocking-for-windows-server-2022/</url>
      
        <content type="html"><![CDATA[<p>最近从 Windows 10 迁移到了 Windows Server 2022，不过我在设置指纹解锁时发现添加按钮是灰色的，并且系统显示了错误提示 <strong>“Windows Hello 在 Windows Server 上不可用”</strong>。</p><p><img src="1.webp" class="lazyload" data-srcset="1.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>在 Google 上找了一圈并没有找到一个可行的方案，<a href="https://blog.berd.moe/archives/windows-server-2019-setup-pin-and-biometric-login/">这篇 Windows Server 2019 的博客</a> 给出的工具在 2022 中可以加上 PIN，但加上 PIN 后添加指纹的按钮依然是提示不可用的。看来得自己研究一下了。</p><h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>根据前面提到那篇博客给出的思路，我大致翻了一下 <strong>SettingsHandlers_User.dll</strong>，但是并没有找到和指纹解锁 / Windows Hello 有关的东西，猜测 Microsoft 对这块设置进行了重构。</p><p>我并不想去研究整个 UWP APP 的逻辑，于是打开火绒剑观察进程模块。很快就发现进入 <em>登录选项</em> 这个标签时会加载 <strong>SettingsHandlers_Authentication.dll</strong>，相关逻辑应该就藏在这里了。</p><p><img src="2.webp" class="lazyload" data-srcset="2.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>放进 IDA 一看，这个 DLL 中确实有不少和 Windows Hello 相关的逻辑，然而点进函数我却发现这个 DLL 除了包含大量遥测、日志代码，还用了 <strong>eXtended Flow Guard</strong>，这直接让部分逻辑的静态分析变得几乎不可能。</p><p>碰到 <code>_guard_xfg_dispatch_icall_fptr()</code> 的时候，如果是调用 GUID 还可以去注册表翻一翻 CLSID，但碰到参数是几个寄存器的时候就只能傻眼了。</p><p><img src="3.webp" class="lazyload" data-srcset="3.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>没办法直接从 UI 逻辑下手，我试图从导入表中找到 WBF 相关内容然后反向追回去，但是却发现这个 DLL 没有 WBF 相关的导入。猜测微软的设计模式和之前那篇分析 2019 的博客中提到的相同，还是把相关的注册组件拆成了一个独立组件。</p><p>除此之外，根据这个 DLL 的逻辑粗略分析，按钮的 <code>SetupOrAddFingerprintSetting::get_IsApplicable()</code> 只是简单的从一个变量里读取了这些信息然后直接返回，而 <code>SetupOrAddFingerprintSetting::get_IsEnabled()</code> 等函数是通过 XFG 动态计算的值。猜测 Windows Server 的相关检测也放到了前文提到的独立组件中，或者在进入设置页面的时候就已经全部计算好了。无论如何，我决定先放弃这个文件，看看能不能找到那个 “独立组件”。</p><h3 id="凭据注册管理器"><a href="#凭据注册管理器" class="headerlink" title="凭据注册管理器"></a>凭据注册管理器</h3><p>花了一点时间把 System32 下带 Enrollment 字样的 DLL/EXE 文件全部翻了一遍，最后我定位到了 <strong>CredentialEnrollmentManager.exe</strong> 这个文件上。</p><p>这个 EXE 的标题为 <strong>凭据注册管理器</strong>，关联到服务 <strong>CredentialEnrollmentManagerUserSvc</strong>，并且它在我们进入 <em>登录选项</em> 标签时会被自动启动。加之导入表中有 <code>WinBio</code> 相关的一系列函数以及之前那篇分析 2019 的博客提到的 <code>EnrollPin</code> 函数，我猜测实际的注册逻辑和判断逻辑都在这里。</p><p><img src="4.webp" class="lazyload" data-srcset="4.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p><img src="5.webp" class="lazyload" data-srcset="5.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><h3 id="PIN-注册判断"><a href="#PIN-注册判断" class="headerlink" title="PIN 注册判断"></a>PIN 注册判断</h3><p>从之前在普通 Windows 10 中配置指纹的经验来看，还是必须有 PIN 才能设置指纹，所以这里先研究 PIN 的注册判断逻辑 (事实证明这个决定非常正确)。</p><p>根据函数名一个一个看，排除掉 <code>PinEnrollment::v_IsSupported()</code> 后很快我们就看到了 <code>PinEnrollment::v_CanEnroll()</code> 这个很明显是某种判断的函数。调试一下，很容易发现前面两个对自身变量的判断是通过了的，而在 <code>PinEnrollment::CanAddPin()</code> 这里返回了 <code>false</code> 导致我们不能添加 PIN“：</p><p><img src="6.webp" class="lazyload" data-srcset="6.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>追进 <code>PinEnrollment::CanAddPin()</code>，很容易发现第一个判断 <code>this-&gt;byteE8</code> 就没有通过：</p><p><img src="7.webp" class="lazyload" data-srcset="7.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>再花一点时间找寻找写这个内存的地方，最后找到了 <code>PinEnrollment::RefreshPolicy()</code> 这个函数。仔细一看，上面大多是一些读取用户配置、组策略配置之类的内容，而往下翻我们很快就看到了一个重要的判断 <code>!IsOS(0x1Du)</code>：</p><p><img src="8.webp" class="lazyload" data-srcset="8.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>这个 <code>IsOS</code> 是什么东西呢？让我们看看 <a href="https://docs.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-isos">Win32 API 文档</a>：</p><details blue quote><summary> IsOS function (shlwapi.h) </summary>              <div class='content'>              <p>Checks for specified operating systems and operating system features.</p><p><strong>dwOS</strong>: A value that specifies which operating system or operating system feature to check for. One of the following values (you cannot combine values).</p><p><strong>Return value</strong>: Returns a nonzero value if the specified operating system or operating system feature is detected, otherwise FALSE.</p><p><img src="10.webp" class="lazyload" data-srcset="10.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>              </div>            </details><p>再结合这里传入的 <code>0x1D</code> 分析，很明显这就是我们要找的判断了。</p><h3 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h3><p>用 IDA 打一个简单的补丁 (如果你喜欢，这里换成 jnz 也行)：</p><p><img src="11.webp" class="lazyload" data-srcset="11.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>然后我们覆盖一下文件并杀掉之前的进程，重新进入 <em>登录选项</em> 标签，添加 PIN 的按钮就可以正常使用了。除此之外，添加指纹的组件也可以正常工作，看起来这个 Policy 判断是针对 Windows Hello 而不是单纯针对 PIN 的。</p><p><img src="12.webp" class="lazyload" data-srcset="12.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><div class="note "><p><strong>注意事项：文件权限</strong></p><p>覆盖文件的过程中可能会碰到权限问题，你可以通过 <a href="https://github.com/M2Team/NSudo">NSudo</a> 拉起一个 <strong>TrustedInstaller</strong> 权限的命令提示符完成覆盖操作。</p><p>为了确保操作系统的安全性不受破坏，你应该使用 <code>icacls /save</code> 命令来备份 <strong>CredentialEnrollmentManager.exe</strong> 的 ACL 并在替换完成后使用 <code>icacls /restore</code> 进行还原。</p><p>当然，你也可以选择手动设置 ACL，条条大路通罗马。</p></div><h3 id="修改好的文件"><a href="#修改好的文件" class="headerlink" title="修改好的文件"></a>修改好的文件</h3><p>如果你手上没有 IDA 或者不想自己动手，也可以直接使用我修改好的 <strong>CredentialEnrollmentManager.exe</strong>：</p><span class='btn large'><a class="button" href='CredentialEnrollmentManager_patched.zip' title='点击下载'><i class='fa fa-download'></i>点击下载</a></span><p>我不能保证这个文件一定能工作，也不能保证它不会损坏你的计算机，你将需要自行承担可能存在的风险。如果你同意承担此风险，我会告诉你解压密码是小写的 <code>xwtf</code>。</p><div class="note warning"><p><strong>注意事项：管理员账户</strong></p><p>Windows Server 的内建 Administrator 账户并不支持配置指纹解锁。如果你尝试进行配置，就会碰到这样的错误：</p><p><img src="13.webp" class="lazyload" data-srcset="13.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p><p>日常使用 Administrator 账户也不是一个好习惯，建立一个独立的 <em>User + Administrators</em> 组账户就可以使用指纹解锁了。</p><p><img src="14.webp" class="lazyload" data-srcset="14.webp" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> Windows Server 2022 </tag>
            
            <tag> Windows Hello </tag>
            
            <tag> 指纹解锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/hello-world/"/>
      <url>/2021/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
